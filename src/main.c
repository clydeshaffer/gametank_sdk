#include "gametank.h"
#include "drawing_funcs.h"
#include "dynawave.h"
#include "music.h"
#include "gen/assets/gfx.h"
#include "input.h"

#define BRICKS_LEFT_EDGE 16
#define BRICKS_RIGHT_EDGE 112
#define BRICKS_TOTAL_WIDTH 96
#define BRICKS_TOTAL_HEIGHT 24
#define BRICKS_TOP_EDGE 24
#define BRICKS_BOTTOM_EDGE 48
#define BRICKS_WIDTH 8
#define BRICKS_HEIGHT 4
#define BRICKS_WIDTH_SHIFT 3
#define BRICKS_HEIGHT_SHIFT 2

#define PLAYER_LIMIT_LEFT 17
#define PLAYER_LIMIT_RIGHT 111

char boxes[96];

char check_brick_hit(unsigned char x, unsigned char y) {
    x -= BRICKS_LEFT_EDGE;
    y -= BRICKS_TOP_EDGE;
    if(x >= BRICKS_TOTAL_WIDTH) return 0;
    if(y >= BRICKS_TOTAL_HEIGHT) return 0;
    x = x >> BRICKS_WIDTH_SHIFT;
    y = y >> BRICKS_HEIGHT_SHIFT;
    return (x + (y << 4)) + 1;
}

char check_player_hit(unsigned char bx, unsigned char px) {
    px -= bx;
    if(px > 127) {
        px = (~px)+1;
    }
    return (px < 18);
}

void setup_bricks() {
    unsigned char i,k;
    i = 0;
    for(k = 0; k < 96; ++k) {
        if((k & 15) <= 12) {
            boxes[k] = (i & 7) << 3;
            ++i;
        } else {
            boxes[k] = 0xFF;
        }
    }
}

int main () {
    char i, j, k;
    char ball_alive = 1;
    char ball_x = 64, ball_y = 64;
    char ball_dx = 1, ball_dy = 255;
    char global_tick_counter = 0;
    char player_x = 64;
    char death_count = 0;

    //Put the game engine systems into a clean state
    init_graphics();
    init_dynawave();
    init_music();

    setup_bricks();

    //There are 32 128x128 slots available for sprite sheets in Video RAM
    //These calls load the ball, player, bricks, and background into slots zero through three.
    //The "ASSET__blah" names come from header files generated by the "make import" command.
    load_spritesheet(&ASSET__gfx__ball_bmp, 0);
    load_spritesheet(&ASSET__gfx__player_bmp, 1);
    load_spritesheet(&ASSET__gfx__bricks_bmp, 2);
    load_spritesheet(&ASSET__gfx__background1_bmp, 3);

    //Paint the edges of the screen black
    //clear_border uses the queued drawing system
    clear_border(0);
    //flip_pages would interrupt drawing, so we wait for the queue to finish first
    await_draw_queue();
    flip_pages();
    //clear the border on the second framebuffer
    clear_border(0);
    await_draw_queue();

    while (1) {
        //Read the controllers and update the global player1_buttons and player2_buttons variables
        update_inputs();

        //Submit a sprite to the queue
        //This function fetches sprite clipping data that was exported from Aseprite
        draw_sprite_frame(
            &ASSET__gfx__background1_json, //Handle for sprite table
            64, 64, //draw_sprite_frame draws from the center of a sprite
            0, //Frame number
            SPRITE_FLIP_NONE, //Sprite flipping options
            3 //VRAM slot number (see load_spritesheet above)
        );
        
        if(ball_alive) {
            ball_x += ball_dx;
            ball_y += ball_dy;
            if(ball_x == 4) {
                ball_dx = 1;
            } else if(ball_x == 119) {
                ball_dx = 255;
            }
            if(ball_y == 16) {
                ball_dy = 1;
            } else if((ball_y == 108) && check_player_hit(ball_x, player_x)) {
                ball_dy = 255;
            } else if(ball_y == 127) {
                ++death_count;
                ball_alive = 0;
                global_tick_counter = 0;

                //Triggers a simple sound effect on the noise channel with a given pitch, pitch bend rate, and duration.
                do_noise_effect(80, -8, 10);
            }

            k = check_brick_hit(ball_x, ball_y);
            if(k && (boxes[k-1] != 0xFF)) {
                boxes[k-1] = 0xFF;
                do_noise_effect(95, 12, 4);
                if((ball_x & 7) == 0) {
                    ball_dx = 255;
                    ball_x += ball_dx;
                    ball_x += ball_dx;
                } else if((ball_x & 7) == 7) {
                    ball_dx = 1;
                    ball_x += ball_dx;
                    ball_x += ball_dx;
                }

                if((ball_y & 3) == 0) {
                    ball_dy = 255;
                    ball_y += ball_dy;
                    ball_y += ball_dy;
                } else if((ball_y & 3) == 3) {
                    ball_dy = 1;
                    ball_y += ball_dy;
                    ball_y += ball_dy;
                }
            }

            //player1_buttons is a bitmask set by update_inputs
            //INPUT_MASK_<NAME> macros come from input.h
            if(player1_buttons & INPUT_MASK_LEFT) {
                --player_x;
            }

            if(player1_buttons & INPUT_MASK_RIGHT) {
                ++player_x;
            }

            if(player_x < PLAYER_LIMIT_LEFT) player_x = PLAYER_LIMIT_LEFT;
            if(player_x > PLAYER_LIMIT_RIGHT) player_x = PLAYER_LIMIT_RIGHT;

            draw_sprite_frame(
                &ASSET__gfx__ball_json,
                ball_x, ball_y,
                (global_tick_counter >> 3) & 3,
                SPRITE_FLIP_NONE,
                0
            );
            draw_sprite_frame(
                &ASSET__gfx__player_json,
                player_x, 116,
                (global_tick_counter >> 3) % 6,
                SPRITE_FLIP_NONE,
                1
            );
            clear_border(0);
        } else {
            clear_border(0);
            if(global_tick_counter < 32) {
                draw_sprite_frame(
                    &ASSET__gfx__player_json,
                    player_x, 116,
                    (global_tick_counter >> 3) + 6,
                    SPRITE_FLIP_NONE,
                    1
                );
            } else if(global_tick_counter == 255) {
                ball_alive = 1;
                ball_x = 64;
                ball_y = 64;
                ball_dx = 1;
                ball_dy = 255;
                player_x = 64;
                setup_bricks();
                if(death_count == 3) {
                    load_spritesheet(&ASSET__gfx__background2_bmp, 3);
                } else if(death_count == 4) {
                    load_spritesheet(&ASSET__gfx__background1_bmp, 3);
                }
            }
        }

        ++global_tick_counter;
        
        await_draw_queue();

        k = 0;
        *dma_flags = flagsMirror;
        for(i = 24; i < 48; i += 4) {
            for(j = 16; j < 112; j += 8) {
                if(boxes[k] != 0xFF) {
                    //The queued sprite system is good for overlapping long sprite draws with other computation.
                    //However the queue adds some overhead and for a large number of small sprites may not be worth the trouble.
                    draw_sprite_now(j, i, 8, 4, boxes[k], 0, GRAM_PAGE(2));
                    //An 8x4 sprite takes only 32 cycles from the DMA engine. It will definitely finish by the time the loop repeats.
                }
                ++k;
            }
            k += 4;
        }

        //Wait for the next video sync and then swap the framebuffers
        //At any given time we draw on one and display the other
        sleep(1);
        flip_pages();

        //Advance the state of the music engine by (ideally) 1/60th of a second
        //Even if there's no music we need this to make do_noise_effect work!
        tick_music();
    }

  return (0);                                     //  We should never get here!
}